/*
 * hashes.c
 * 
 * Copyright 2021 Luis "Laffin" Espinoza <laffintoo at gmail.com>
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 * 
 * 
 */

#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include "symbols.c"

FILE *fopen_or_fatal(const char *fpath, const char* mode) {
	FILE *h = fopen(fpath, mode);
	if(!h) { fprintf("genhashes: Cannot open file: %s\n", fpath); exit(1); }
	return h;
}

void *dynm[128]; int dynm_i=0;

char *strupr_a(const char *s) {
	size_t n = strlen(s)+1;
	char *p = malloc(n);
	if(!p) return "";
	memcpy(p, s, n);
	for (int i = 0; p[i] && i < n; i++) {
		p[i] = toupper(p[i]);
	}
	dynm_i++;
	dynm[dynm_i]=p;
	return p;
}

char *hash_to_str_a(long hash) {
	char *p = malloc(9);
	if(!p) return "";
	snprintf(p, 9, "%8lX", hash);
	if(p[0]==' ') { p[0]='X';}
	dynm_i++;
	dynm[dynm_i]=p;
	return p;
}

int main(int argc, char **argv) {
	FILE *fh;
	st_symbols *sym;
	char line[82], key[41], val[41],ch;
	int cnt=0;
	fh=fopen_or_fatal("qemu-run.defaults","r");
	while(fgets(line, 82, fh)) {
		if(!strchr(line, '=') || line[0] == '#') { continue; }
		size_t len = strlen(line);
		if (len && line[len-2] == '\r') { len--; line[len-1] = '\0'; } 
		if (len && line[len-1] == '\n') { len--; line[len] = '\0'; }
		if (len<3) { continue; }
		char* slice = strtok(line, "=");
		memset(key, 0, 41); memset(val, 0, 41);
		for(int i = 0; slice && strlen(slice) && i<2; i++) {
			if (i==0) { strcpy(key, slice); }
			if (i==1) { strcpy(val, slice); break; }
			slice = strtok(NULL, "=");
		}
		sym_add(key,val);
	}
	fclose(fh);
	fh=fopen_or_fatal("config.h","w");
	fprintf(fh,"//Do not edit this file manually, this should be generated by genhashes.c !\n");
	fprintf(fh,"#ifndef QEMU_RUN_CONFIG_H\n#define QEMU_RUN_CONFIG_H\n");
	fprintf(fh,"enum { ");
	for(sym=sym_first(),cnt=0;sym;cnt++,sym=sym_next()) {
		fprintf(fh,"KEY_%s,",strupr_a(sym->key));
	}
	fprintf(fh,"KEY_ENDLIST };\n\ntypedef struct {\n\tchar hash[9];\n\tchar *val;\n} st_config;\n\nst_config cfg[%d] = {\n",cnt+1);
	
	for(sym=sym_first(),cnt=0;sym;cnt++,sym=sym_next()) {
		fprintf(fh,"\t{\"%s\", \"%s\"}%s\t\t/* %s */\n",hash_to_str_a(sym->hash),sym->val?sym->val:"",sym->next?",":"",sym->key);
	}
	fprintf(fh,"};\n");
	fprintf(fh,"#endif //QEMU_RUN_CONFIG_H\n");
	fclose(fh);
	
	if (dynm_i) {
		for (cnt=0; cnt<dynm_i;cnt++) { free(dynm[cnt]); }
	}
	return 0;
}
